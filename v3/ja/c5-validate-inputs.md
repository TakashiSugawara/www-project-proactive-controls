---

layout: col-document
tags: OWASP Top Ten Proactive Controls 2018, C5
document: OWASP Top Ten Proactive Controls 2018
order: 9

---

# C5: 全入力の検証

## 概要

入力バリデーションとは適切にフォーマットされたデータのみがソフトウェアシステムのコンポーネントに入力されるようにするプログラミング技術です。


### 構文検証と意味検証

アプリケーションは、いかなる場合でも(ユーザー表示であっても)データを利用する際には、順に*構文的*にかつ*意味的*に検証しなくてはなりません。

**構文検証**とは、データが期待通りの形式であることです。例えば、ある種の操作を実行するためにユーザーに4桁の数字の「アカウントID」を選ばせるアプリケーションがあるとします。ユーザーがSQLインジェクションのペイロードを入力してくることを想定し、ユーザー入力が正確に4桁の長さで、数字のみで構築されていることを確認しましょう(クエリーパラメーター化する事に加えて)。

**意味検証**とは、所与のアプリケーションの機能やコンテキストでの許容範囲内の入力のみを受け付けることなどです。例えば、日付範囲の指定において、開始日が終了日より前でなくてはなりません。

### ホワイトリスト式かブラックリスト式か

入力の構文検証には、一般的にブラックリスト式とホワイトリスト式と知られている、2つの一般的なアプローチがあります。

* **ブラックリスティング**あるいは**ブラックリスト検証**は、入力値に「既知の良くない」コンテンツが含まれていないかを確認しようとしまうす。例えば、WebアプリケーションにおいてXSS防止のために入力値に正に``<SCRIPT>``という文字が含まれているテキストをブロックすることです。しかしながら、小文字や大文字小文字混合のスクリプトタグを使えばこの防御策は回避されてしまいます。
* **ホワイトリスティング**あるいは**ホワイトリスト検証**は、入力値が「既知の良い」ルールのセットにマッチするかを確認しようとします。例えば、米国州のホワイトリスト検証のルールは、有効な州の一つとして2字にコード化されたものになります。

**重要な事**
安全なアプリケーションの構築のためには、ホワイトリスト検証がお勧めの最小限のアプローチです。ブラックリスト検証はエラーしやすく、様々な回避術により迂回することができます。ブラックリスト検証がよく回避されがちである一方で、明らかな攻撃を見抜くのに役立ちます。そのため、**ホワイトリスト検証**はデータの適切な構文と意味的な妥当性を確かにすることで攻撃を制限し、**ブラックリスト検証**は明らかな攻撃を見抜き、潜在的に防止するのに役立ちます。

### クライアントサイド検証とサーバーサイド検証

安全のためには、入力値検証は全てサーバーサイドで実施しなくてはなりません。クライアントサイド検証は機能面からもセキュリティ目的からも有用ですが、容易に回避され得ます。ゆえに、安全のためにはサーバーサイド検証がより根本的なものとなります。例えば、JavaScriptによる検証によってユーザーにある入力欄が数字でなければならないことを警告するとしても、サーバーサイドアプリケーションは受信したデータが適切に処理可能な値域にある数字であるかを確認せねばなりません。

### 正規表現

正規表現によって、データがあるパターンにマッチするかを確認することができます。基礎的な例から始めます。

以下の正規表現はユーザー名検証のホワイトリスト検証ルールを定義するために用いられているものです。

    ^[a-z0-9_]{3,16}$

この正規表現は英数小文字とアンダースコアのみを許容します。またユーザー名は3から16文字の長さに制限されます。

**警告: サービス拒否の可能性**

正規表現の作成時には注意が必要です。不適切な設計の表現はサービス拒否状態(別名[ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS))の可能性となり得ます。正規表現がReDoSに対して脆弱でないことを確認する試験には、様々なツールを使えます。

**警告: 複雑性**

正規表現は検証を実施するための一つの方法に過ぎません。正規表現をメンテナンスしたり理解したりするのが難しい開発者はいます。他の検証方法としてプログラムとして検証メソッドを書けば、そのような開発者にとっても容易にメンテナンスできるものとなります。

### 入力検証の限界

**複雑な入力形式では「検証が正則」であってもまだ危険な場合があるので、入力値検証が必ずしもデータを「安全」にする訳ではありません。例えば、正則なemailアドレスはSQLインジェクションとなり得ますし、正則なURLはXSS攻撃となり得ます。**入力値検証に加えて、クエリーパラメータ化やエスケーピングなどの追加防御策を常にしましょう。

### シリアルデータの検証の課題

複雑に過ぎてアプリケーションを最低限にしか保護できない入力形式があります。例えば、攻撃者に調整されている可能性があるような信頼できないデータをデシリアライズすることは危険です。唯一の安全なアーキテクチャパターンは、信頼できないソースからのシリアルデータを受け入れないか、単純なデータ形式のみに対し制限された容量の下でデシリアライズをすることです。可能な限りシリアルデータ処理を避け、JSONのように防御しやすい形式を利用しましょう。

もしシリアルデータ処理が避けられないのであれば、一連の検証による防御を考えに入れてください。

* 悪意のあるオブジェクトの作成やデータ改竄の防止のために、完全性の確認やシリアルデータを暗号化して下さい。
* オブジェクト作成前のデシリアライズ時に厳格な型制約を適用して下さい。一般的なコードはクラスの集合として定義されることを期待しています。この技術には回避手段が発表されています。
* デシリアライズ処理は、一時的なコンテナなど非常に低い権限環境で実行するなど、隔離して下さい。
* 期待外の型が入力された場合やデシリアライズ処理で例外がスローされた場合など、デシリアライズ処理の例外や失敗をセキュリティログに保存して下さい。
* デシリアライズするコンテナやサーバーのネットワーク入出力を制限し、また監視して下さい。
* ユーザーが継続的にデシリアライズ処理を行っている場合にはアラートを発して、監視して下さい。

### 期待していないユーザー入力 (大量アサインメント)

HTTPリクエストのパラメーターをサーバーサイドのアプリケーションで利用中のオブジェクトに自動バインドするフレームワークがあります。変更を想定されていないサーバーサイドのオブジェクトを攻撃者がこの自動バインド機能を利用して変更できます。この機能によって攻撃者は自身のアクセス制御レベルを変更したり、想定されたビジネスロジックの回避することが可能となります。

この攻撃手法には大量アサインメントであったり、自動バインディングであったり、オブジェクトインジェクションであったり、多くの名前が付けられています。

ユーザーオブジェクトに privilege フィールドでアプリケーションの特権レベルを持っており、悪意のあるユーザーがユーザーデータが変更されるページを探し出し、送信HTTPパラメーターに privilege=admin を追加することができる単純な例を考えます。不安全にも自動バインディングが有効であれば、サーバーサイドのユーザーオブジェクトはその通りに変更されてしまいます。

これの制御には2つのアプローチがとれます。

* 直接的な入力のバインドを避け、その代わりにデータ転送オブジェクト(DTOs)を使います。
* 自動バインドを有効化したとしても、各ページや機能において自動バインド可能なフィールドのホワイトリストを用意します。

より多くの例が[OWASP Mass Assignment Cheat Sheet](https://www.owasp.org/index.php/Mass_Assignment_Cheat_Sheet)にあります。

### HTMLの検証と無毒化

(HTMLコンテンツのWYSIWYGエディタや、HTML直接入力機能を介して)ユーザーからのHTML入力を受け付けるアプリケーションについて考えてみましょう。この場合、検証やエスケーピングは役に立ちません。

* 正規表現はHTML5の複雑性を解釈するのに十分な表現力がありません。
* エンコーディングやエスケーピングでは、HTMLを正しく表示できないので役に立ちません。

そのため、HTMLテキストをパースし綺麗にするライブラリが必要となります。HTML無毒化については[XSS Prevention Cheat Sheet on HTML Sanitization](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet#RULE_.236_-_Sanitize_HTML_Markup_with_a_Library_Designed_for_the_Job)をご覧下さい。

### 検証用のライブラリやフレームワーク

全ての言語や殆どのフレームワークでは、データ検証で利用できるように検証用のライブラリーや関数を用意しています。検証ライブラリーは大抵は標準的なデータ型、長さ要件、値域、nullチェックその他もろもろをカバーしています。多くの検証用ライブラリーやフレームワークでは、プログラマーがアプリケーション全体で利用できるように、独自の正規表現やカスタムバリデーションロジックを定義できます。検証機能の例として、PHPの[filter functions](https://secure.php.net/manual/en/filter.examples.validation.php)やJavaの[Hibernate Validator](http://hibernate.org/validator/)があります。HTML無毒化の例として、[Ruby on Rails sanitize method](http://edgeapi.rubyonrails.org/classes/ActionView/Helpers/SanitizeHelper.html)や[OWASP Java HTML Sanitizer](https://www.owasp.org/index.php/OWASP_Java_HTML_Sanitizer_Project)、[DOMPurify](https://github.com/cure53/DOMPurify)があります。

## 本対策で防げる脆弱性

* 入力検証はアプリケーションへの攻撃を減少させたり、時には難しくしたりします。
* 入力検証はある種の攻撃に特有なデータ形式について安全を確保する技術であり、広範なセキュリティルールとして用いる事はできません。
* 入力値検証は[XSS](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)や[SQL Injection](https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet)、その他の攻撃への主要な対策として用いてはなりません。

## 参考文献

* [OWASP Cheat Sheet: Input Validation](https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet)
* [OWASP Cheat Sheet: iOS - Security Decisions via Untrusted Inputs](https://www.owasp.org/index.php/IOS_Developer_Cheat_Sheet#Security_Decisions_via_Untrusted_Inputs_.28M7.29)
* [OWASP Testing Guide: Testing for Input Validation](https://www.owasp.org/index.php/Testing_for_Input_Validation)

## ツール

* [OWASP Java HTML Sanitizer Project](https://www.owasp.org/index.php/OWASP_Java_HTML_Sanitizer)
* [Java JSR-303/JSR-349 Bean Validation](http://beanvalidation.org/)
* [Java Hibernate Validator](http://hibernate.org/validator/)
* [JEP-290 Filter Incoming Serialization Data](http://openjdk.java.net/jeps/290)
* [Apache Commons Validator](https://commons.apache.org/proper/commons-validator/)
* PHP’s [filter functions](https://secure.php.net/manual/en/book.filter.php)
